import { NextRequest, NextResponse } from "next/server";
import { execSync } from "child_process";

function getGatewayConfig() {
  try {
    const configRaw = require("fs").readFileSync((process.env.OPENCLAW_DIR || "/root/.openclaw") + "/openclaw.json", "utf-8");
    const config = JSON.parse(configRaw);
    return {
      token: config.gateway?.auth?.token || "",
      port: config.gateway?.port || 18789,
    };
  } catch {
    return { token: "", port: 18789 };
  }
}

// GET: List all cron jobs from the OpenClaw gateway
export async function GET() {
  try {
    const output = execSync("openclaw cron list --json --all 2>/dev/null", {
      timeout: 10000,
      encoding: "utf-8",
    });

    const data = JSON.parse(output);
    const jobs = (data.jobs || []).map((job: Record<string, unknown>) => ({
      id: job.id,
      agentId: job.agentId || "main",
      name: job.name || "Unnamed",
      enabled: job.enabled ?? true,
      createdAtMs: job.createdAtMs,
      updatedAtMs: job.updatedAtMs,
      schedule: job.schedule,
      sessionTarget: job.sessionTarget,
      payload: job.payload,
      delivery: job.delivery,
      state: job.state,
      // Derived fields for the UI
      description: formatDescription(job),
      scheduleDisplay: formatSchedule(job.schedule as Record<string, unknown>),
      timezone: (job.schedule as Record<string, string>)?.tz || "UTC",
      nextRun: (job.state as Record<string, unknown>)?.nextRunAtMs
        ? new Date((job.state as Record<string, number>).nextRunAtMs).toISOString()
        : null,
      lastRun: (job.state as Record<string, unknown>)?.lastRunAtMs
        ? new Date((job.state as Record<string, number>).lastRunAtMs).toISOString()
        : null,
    }));

    return NextResponse.json(jobs);
  } catch (error) {
    console.error("Error fetching cron jobs from gateway:", error);
    return NextResponse.json(
      { error: "Failed to fetch cron jobs from OpenClaw gateway" },
      { status: 500 }
    );
  }
}

function formatDescription(job: Record<string, unknown>): string {
  const payload = job.payload as Record<string, unknown>;
  if (!payload) return "";
  if (payload.kind === "agentTurn") {
    const msg = (payload.message as string) || "";
    return msg.length > 120 ? msg.substring(0, 120) + "..." : msg;
  }
  if (payload.kind === "systemEvent") {
    const text = (payload.text as string) || "";
    return text.length > 120 ? text.substring(0, 120) + "..." : text;
  }
  return "";
}

function formatSchedule(schedule: Record<string, unknown>): string {
  if (!schedule) return "Unknown";
  switch (schedule.kind) {
    case "cron":
      return `${schedule.expr}${schedule.tz ? ` (${schedule.tz})` : ""}`;
    case "every":
      const ms = schedule.everyMs as number;
      if (ms >= 3600000) return `Every ${ms / 3600000}h`;
      if (ms >= 60000) return `Every ${ms / 60000}m`;
      return `Every ${ms / 1000}s`;
    case "at":
      return `Once at ${schedule.at}`;
    default:
      return JSON.stringify(schedule);
  }
}

// POST: Create a new cron job (openclaw cron add)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { name, description, schedule, timezone } = body;

    if (!name || typeof name !== "string" || !name.trim()) {
      return NextResponse.json({ error: "Job name is required" }, { status: 400 });
    }
    const cronExpr = typeof schedule === "string" ? schedule.trim() : (schedule as { expr?: string })?.expr;
    if (!cronExpr) {
      return NextResponse.json({ error: "Cron schedule is required" }, { status: 400 });
    }

    const tz = (typeof timezone === "string" && timezone.trim()) ? timezone.trim() : "UTC";
    const msg = typeof description === "string" ? description.trim() : "";
    const shellEscape = (s: string) => `'${s.replace(/'/g, "'\"'\"'")}'`;
    const cmd = [
      "openclaw cron add",
      "--name", shellEscape(name.trim()),
      "--cron", shellEscape(cronExpr),
      "--tz", shellEscape(tz),
      "--session main",
      msg ? `--message ${shellEscape(msg)}` : "",
    ].filter(Boolean).join(" ") + " 2>/dev/null";

    execSync(cmd, {
      timeout: 10000,
      encoding: "utf-8",
    });

    return NextResponse.json({ success: true, created: true });
  } catch (error) {
    console.error("Error creating cron job:", error);
    return NextResponse.json(
      { error: "Failed to create cron job" },
      { status: 500 }
    );
  }
}

// PUT: Toggle enable/disable and optionally edit job (name, schedule, timezone, description)
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, enabled, name, schedule, timezone, description } = body;

    if (!id) {
      return NextResponse.json({ error: "Job ID is required" }, { status: 400 });
    }

    const safeId = String(id).replace(/[^a-zA-Z0-9_-]/g, "");

    // If editing fields are provided, try cron edit first
    const cronExpr = typeof schedule === "string" ? schedule?.trim() : (schedule as { expr?: string })?.expr;
    const shellEscape = (s: string) => `'${s.replace(/'/g, "'\"'\"'")}'`;
    if (name !== undefined || cronExpr !== undefined || timezone !== undefined || description !== undefined) {
      try {
        const editParts = [`openclaw cron edit ${safeId}`];
        if (typeof name === "string" && name.trim()) editParts.push("--name", shellEscape(name.trim()));
        if (cronExpr) editParts.push("--cron", shellEscape(cronExpr));
        if (typeof timezone === "string" && timezone.trim()) editParts.push("--tz", shellEscape(timezone.trim()));
        if (typeof description === "string") editParts.push("--message", shellEscape(description.trim()));
        if (editParts.length > 1) {
          execSync(editParts.join(" ") + " 2>/dev/null", { timeout: 10000, encoding: "utf-8" });
        }
      } catch (editErr) {
        console.warn("Cron edit failed (CLI may not support all fields):", editErr);
      }
    }

    // Enable/disable
    if (typeof enabled === "boolean") {
      const action = enabled ? "enable" : "disable";
      execSync(
        `openclaw cron ${action} ${safeId} --json 2>/dev/null || openclaw cron update ${safeId} --enabled=${enabled} --json 2>/dev/null`,
        { timeout: 10000, encoding: "utf-8" }
      );
    }

    return NextResponse.json({ success: true, id: safeId, enabled });
  } catch (error) {
    console.error("Error updating cron job:", error);
    return NextResponse.json(
      { error: "Failed to update cron job" },
      { status: 500 }
    );
  }
}

// DELETE: Remove a cron job
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json({ error: "Job ID is required" }, { status: 400 });
    }

    execSync(`openclaw cron remove ${id} 2>/dev/null`, {
      timeout: 10000,
      encoding: "utf-8",
    });

    return NextResponse.json({ success: true, deleted: id });
  } catch (error) {
    console.error("Error deleting cron job:", error);
    return NextResponse.json(
      { error: "Failed to delete cron job" },
      { status: 500 }
    );
  }
}
